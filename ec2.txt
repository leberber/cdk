

=== ap_helper.py ===

import os
import sys

def combine_files_with_headers_recursive(folder_path, output_file, extensions=None, extra_files=None, exclude_dirs=None, exclude_files=None):
    """
    Combines files with specified extensions or extra filenames into one output.
    Skips specified folders, files, and unreadable/binary files.
    
    :param folder_path: Root directory to start.
    :param output_file: Output file path.
    :param extensions: List of allowed file extensions (e.g., ['.py', '.txt']).
    :param extra_files: List of extra filenames without extensions (e.g., ['Dockerfile', '.env']).
    :param exclude_dirs: Set of directory names to exclude (e.g., {'.venv', 'node_modules'}).
    :param exclude_files: Set of filenames to exclude (e.g., {'package-lock.json'}).
    """
    if exclude_dirs is None:
        exclude_dirs = {'__pycache__', '.venv', 'node_modules', '.git'}
    
    if exclude_files is None:
        exclude_files = set()

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(folder_path):
            dirs[:] = [d for d in dirs if d not in exclude_dirs]

            for filename in sorted(files):
                # Skip excluded files
                if filename in exclude_files:
                    continue
                    
                file_path = os.path.join(root, filename)
                relative_path = os.path.relpath(file_path, folder_path)

                _, ext = os.path.splitext(filename)

                if ext in ('.pyc', '.pyo', '.so', '.dll'):
                    continue

                if (extensions and ext not in extensions) and (extra_files and filename not in extra_files):
                    continue

                outfile.write(f"\n\n=== {relative_path} ===\n\n")
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        outfile.write(infile.read())
                except Exception as e:
                    print(f"Skipping {relative_path}: {e}")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python script.py <input_directory>")
        sys.exit(1)

    input_folder = os.path.abspath(sys.argv[1])

    if not os.path.isdir(input_folder):
        print(f"Error: '{input_folder}' is not a valid directory.")
        sys.exit(1)

    script_dir = os.path.dirname(os.path.abspath(__file__))
    output_file_path = os.path.join(script_dir, f"{sys.argv[1]}.txt")

    combine_files_with_headers_recursive(
        folder_path=input_folder,
        output_file=output_file_path,
        extensions=[".py", ".txt", ".yml", ".yaml", ".md", ".json", ".ts", ".scss"],
        extra_files=["Dockerfile", ".gitignore", ".env"],  # Removed package-lock.json from here
        exclude_dirs={'.venv', 'node_modules', '__pycache__', '.git', '.angular', 'sql', 'sql new'},  # Removed package-lock.json from here
        exclude_files={'package-lock.json'}  # Added new parameter to exclude this file
    )

=== ec2.txt ===



=== tree.py ===

from directory_tree import DisplayTree
import os

if __name__ == '__main__':
    DisplayTree(
        os.path.abspath('ec2'), 
        ignoreList=['.git', 'node_modules', '__pycache__', '.pytest_cache'],
         showHidden=True
        
    )

=== infra/ec2_stack.py ===

from aws_cdk import (
    Stack,
    CfnOutput,
    aws_ec2 as ec2,
)
from constructs import Construct


class Ec2ProjectStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Use default VPC
        vpc = ec2.Vpc.from_lookup(self, "DefaultVpc", is_default=True)

        # Create security group
        security_group = ec2.SecurityGroup(
            self, "WebServerSG",
            vpc=vpc,
            description="Security group for web server",
            allow_all_outbound=True
        )

        # Allow SSH
        security_group.add_ingress_rule(
            ec2.Peer.any_ipv4(),
            ec2.Port.tcp(22),
            "Allow SSH"
        )

        # Allow HTTP
        security_group.add_ingress_rule(
            ec2.Peer.any_ipv4(),
            ec2.Port.tcp(80),
            "Allow HTTP"
        )

        # Create EC2 instance (free tier eligible)
        instance = ec2.Instance(
            self, "WebServer",
            instance_type=ec2.InstanceType.of(
                ec2.InstanceClass.T2, 
                ec2.InstanceSize.MICRO
            ),  # Free tier
            machine_image=ec2.MachineImage.latest_amazon_linux2(),
            vpc=vpc,
            security_group=security_group,
            key_name="my-key-pair"  # The key pair you created in AWS console
        )

        # Output the public IP
        CfnOutput(
            self, "PublicIP",
            value=instance.instance_public_ip,
            description="Public IP of the EC2 instance"
        )

        # Output SSH command
        CfnOutput(
            self, "SSHCommand",
            value=f"ssh -i my-key-pair.pem ec2-user@{instance.instance_public_ip}",
            description="SSH command to connect to the instance"
        )

=== infra/main.py ===

#!/usr/bin/env python3
import os
import aws_cdk as cdk
from ec2_stack import Ec2ProjectStack

app = cdk.App()
Ec2ProjectStack(app, "MyEc2ProjectStack",
    env=cdk.Environment(
        account=os.getenv('CDK_DEFAULT_ACCOUNT'),
        region=os.getenv('CDK_DEFAULT_REGION')
    )
)

app.synth()

=== backend/main.py ===


# ==================== backend/main.py ====================
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlmodel import SQLModel, Field, create_engine, Session, select
from typing import Optional, List
import os

# Database Model
class Item(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    description: Optional[str] = None

# Database setup
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")
engine = create_engine(DATABASE_URL, echo=True)

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

def get_session():
    with Session(engine) as session:
        yield session

# FastAPI app
app = FastAPI(title="Minimal API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
def on_startup():
    create_db_and_tables()

@app.get("/health")
def health():
    return {"status": "ok"}

@app.get("/api/items", response_model=List[Item])
def get_items(session: Session = Depends(get_session)):
    items = session.exec(select(Item)).all()
    return items

@app.post("/api/items", response_model=Item)
def create_item(item: Item, session: Session = Depends(get_session)):
    session.add(item)
    session.commit()
    session.refresh(item)
    return item

@app.delete("/api/items/{item_id}")
def delete_item(item_id: int, session: Session = Depends(get_session)):
    item = session.get(Item, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    session.delete(item)
    session.commit()
    return {"message": "Item deleted"}

=== backend/requirements.txt ===

fastapi==0.104.1
uvicorn==0.24.0
sqlmodel==0.0.14